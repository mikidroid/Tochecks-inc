{"ast":null,"code":"import { clamp, getDistance, getDistances } from \"../../Utils/NumberUtils\";\nimport { isInArray } from \"../../Utils/Utils\";\nexport function applyDistance(particle) {\n  const initialPosition = particle.initialPosition;\n  const {\n    dx,\n    dy\n  } = getDistances(initialPosition, particle.position);\n  const dxFixed = Math.abs(dx),\n    dyFixed = Math.abs(dy);\n  const hDistance = particle.retina.maxDistance.horizontal;\n  const vDistance = particle.retina.maxDistance.vertical;\n  if (!hDistance && !vDistance) {\n    return;\n  }\n  if ((hDistance && dxFixed >= hDistance || vDistance && dyFixed >= vDistance) && !particle.misplaced) {\n    particle.misplaced = !!hDistance && dxFixed > hDistance || !!vDistance && dyFixed > vDistance;\n    if (hDistance) {\n      particle.velocity.x = particle.velocity.y / 2 - particle.velocity.x;\n    }\n    if (vDistance) {\n      particle.velocity.y = particle.velocity.x / 2 - particle.velocity.y;\n    }\n  } else if ((!hDistance || dxFixed < hDistance) && (!vDistance || dyFixed < vDistance) && particle.misplaced) {\n    particle.misplaced = false;\n  } else if (particle.misplaced) {\n    const pos = particle.position,\n      vel = particle.velocity;\n    if (hDistance && (pos.x < initialPosition.x && vel.x < 0 || pos.x > initialPosition.x && vel.x > 0)) {\n      vel.x *= -Math.random();\n    }\n    if (vDistance && (pos.y < initialPosition.y && vel.y < 0 || pos.y > initialPosition.y && vel.y > 0)) {\n      vel.y *= -Math.random();\n    }\n  }\n}\nexport function spin(particle, moveSpeed) {\n  const container = particle.container;\n  if (!particle.spin) {\n    return;\n  }\n  const updateFunc = {\n    x: particle.spin.direction === \"clockwise\" ? Math.cos : Math.sin,\n    y: particle.spin.direction === \"clockwise\" ? Math.sin : Math.cos\n  };\n  particle.position.x = particle.spin.center.x + particle.spin.radius * updateFunc.x(particle.spin.angle);\n  particle.position.y = particle.spin.center.y + particle.spin.radius * updateFunc.y(particle.spin.angle);\n  particle.spin.radius += particle.spin.acceleration;\n  const maxCanvasSize = Math.max(container.canvas.size.width, container.canvas.size.height);\n  if (particle.spin.radius > maxCanvasSize / 2) {\n    particle.spin.radius = maxCanvasSize / 2;\n    particle.spin.acceleration *= -1;\n  } else if (particle.spin.radius < 0) {\n    particle.spin.radius = 0;\n    particle.spin.acceleration *= -1;\n  }\n  particle.spin.angle += moveSpeed / 100 * (1 - particle.spin.radius / maxCanvasSize);\n}\nexport function applyPath(particle, delta) {\n  const particlesOptions = particle.options;\n  const pathOptions = particlesOptions.move.path;\n  const pathEnabled = pathOptions.enable;\n  if (!pathEnabled) {\n    return;\n  }\n  const container = particle.container;\n  if (particle.lastPathTime <= particle.pathDelay) {\n    particle.lastPathTime += delta.value;\n    return;\n  }\n  const path = container.pathGenerator.generate(particle);\n  particle.velocity.addTo(path);\n  if (pathOptions.clamp) {\n    particle.velocity.x = clamp(particle.velocity.x, -1, 1);\n    particle.velocity.y = clamp(particle.velocity.y, -1, 1);\n  }\n  particle.lastPathTime -= particle.pathDelay;\n}\nexport function getProximitySpeedFactor(particle) {\n  const container = particle.container;\n  const options = container.actualOptions;\n  const active = isInArray(\"slow\", options.interactivity.events.onHover.mode);\n  if (!active) {\n    return 1;\n  }\n  const mousePos = particle.container.interactivity.mouse.position;\n  if (!mousePos) {\n    return 1;\n  }\n  const particlePos = particle.getPosition();\n  const dist = getDistance(mousePos, particlePos);\n  const radius = container.retina.slowModeRadius;\n  if (dist > radius) {\n    return 1;\n  }\n  const proximityFactor = dist / radius || 0;\n  const slowFactor = options.interactivity.modes.slow.factor;\n  return proximityFactor / slowFactor;\n}","map":null,"metadata":{},"sourceType":"module"}