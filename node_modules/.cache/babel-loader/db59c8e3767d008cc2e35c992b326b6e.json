{"ast":null,"code":"import { calcEasing, clamp, getDistances } from \"../../../Utils/NumberUtils\";\nimport { divMode, divModeExecute, isDivModeEnabled, isInArray } from \"../../../Utils/Utils\";\nimport { Circle } from \"../../../Core/Utils/Circle\";\nimport { Constants } from \"../../../Core/Utils/Constants\";\nimport { ExternalInteractorBase } from \"../../../Core/Utils/ExternalInteractorBase\";\nimport { Rectangle } from \"../../../Core/Utils/Rectangle\";\nimport { Vector } from \"../../../Core/Utils/Vector\";\nexport class Repulser extends ExternalInteractorBase {\n  constructor(container) {\n    super(container);\n    if (!container.repulse) {\n      container.repulse = {\n        particles: []\n      };\n    }\n    this.handleClickMode = mode => {\n      const options = this.container.actualOptions;\n      if (mode !== \"repulse\") {\n        return;\n      }\n      if (!container.repulse) {\n        container.repulse = {\n          particles: []\n        };\n      }\n      container.repulse.clicking = true;\n      container.repulse.count = 0;\n      for (const particle of container.repulse.particles) {\n        particle.velocity.setTo(particle.initialVelocity);\n      }\n      container.repulse.particles = [];\n      container.repulse.finish = false;\n      setTimeout(() => {\n        if (!container.destroyed) {\n          if (!container.repulse) {\n            container.repulse = {\n              particles: []\n            };\n          }\n          container.repulse.clicking = false;\n        }\n      }, options.interactivity.modes.repulse.duration * 1000);\n    };\n  }\n  isEnabled() {\n    const container = this.container,\n      options = container.actualOptions,\n      mouse = container.interactivity.mouse,\n      events = options.interactivity.events,\n      divs = events.onDiv,\n      divRepulse = isDivModeEnabled(\"repulse\", divs);\n    if (!(divRepulse || events.onHover.enable && mouse.position || events.onClick.enable && mouse.clickPosition)) {\n      return false;\n    }\n    const hoverMode = events.onHover.mode,\n      clickMode = events.onClick.mode;\n    return isInArray(\"repulse\", hoverMode) || isInArray(\"repulse\", clickMode) || divRepulse;\n  }\n  reset() {}\n  async interact() {\n    const container = this.container,\n      options = container.actualOptions,\n      mouseMoveStatus = container.interactivity.status === Constants.mouseMoveEvent,\n      events = options.interactivity.events,\n      hoverEnabled = events.onHover.enable,\n      hoverMode = events.onHover.mode,\n      clickEnabled = events.onClick.enable,\n      clickMode = events.onClick.mode,\n      divs = events.onDiv;\n    if (mouseMoveStatus && hoverEnabled && isInArray(\"repulse\", hoverMode)) {\n      this.hoverRepulse();\n    } else if (clickEnabled && isInArray(\"repulse\", clickMode)) {\n      this.clickRepulse();\n    } else {\n      divModeExecute(\"repulse\", divs, (selector, div) => this.singleSelectorRepulse(selector, div));\n    }\n  }\n  singleSelectorRepulse(selector, div) {\n    const container = this.container,\n      query = document.querySelectorAll(selector);\n    if (!query.length) {\n      return;\n    }\n    query.forEach(item => {\n      const elem = item,\n        pxRatio = container.retina.pixelRatio,\n        pos = {\n          x: (elem.offsetLeft + elem.offsetWidth / 2) * pxRatio,\n          y: (elem.offsetTop + elem.offsetHeight / 2) * pxRatio\n        },\n        repulseRadius = elem.offsetWidth / 2 * pxRatio,\n        area = div.type === \"circle\" ? new Circle(pos.x, pos.y, repulseRadius) : new Rectangle(elem.offsetLeft * pxRatio, elem.offsetTop * pxRatio, elem.offsetWidth * pxRatio, elem.offsetHeight * pxRatio),\n        divs = container.actualOptions.interactivity.modes.repulse.divs,\n        divRepulse = divMode(divs, elem);\n      this.processRepulse(pos, repulseRadius, area, divRepulse);\n    });\n  }\n  hoverRepulse() {\n    const container = this.container,\n      mousePos = container.interactivity.mouse.position;\n    if (!mousePos) {\n      return;\n    }\n    const repulseRadius = container.retina.repulseModeDistance;\n    this.processRepulse(mousePos, repulseRadius, new Circle(mousePos.x, mousePos.y, repulseRadius));\n  }\n  processRepulse(position, repulseRadius, area, divRepulse) {\n    var _a;\n    const container = this.container,\n      query = container.particles.quadTree.query(area),\n      repulseOptions = container.actualOptions.interactivity.modes.repulse;\n    for (const particle of query) {\n      const {\n          dx,\n          dy,\n          distance\n        } = getDistances(particle.position, position),\n        velocity = ((_a = divRepulse === null || divRepulse === void 0 ? void 0 : divRepulse.speed) !== null && _a !== void 0 ? _a : repulseOptions.speed) * repulseOptions.factor,\n        repulseFactor = clamp(calcEasing(1 - distance / repulseRadius, repulseOptions.easing) * velocity, 0, repulseOptions.maxSpeed),\n        normVec = Vector.create(distance === 0 ? velocity : dx / distance * repulseFactor, distance === 0 ? velocity : dy / distance * repulseFactor);\n      particle.position.addTo(normVec);\n    }\n  }\n  clickRepulse() {\n    const container = this.container;\n    if (!container.repulse) {\n      container.repulse = {\n        particles: []\n      };\n    }\n    if (!container.repulse.finish) {\n      if (!container.repulse.count) {\n        container.repulse.count = 0;\n      }\n      container.repulse.count++;\n      if (container.repulse.count === container.particles.count) {\n        container.repulse.finish = true;\n      }\n    }\n    if (container.repulse.clicking) {\n      const repulseDistance = container.retina.repulseModeDistance,\n        repulseRadius = Math.pow(repulseDistance / 6, 3),\n        mouseClickPos = container.interactivity.mouse.clickPosition;\n      if (mouseClickPos === undefined) {\n        return;\n      }\n      const range = new Circle(mouseClickPos.x, mouseClickPos.y, repulseRadius),\n        query = container.particles.quadTree.query(range);\n      for (const particle of query) {\n        const {\n            dx,\n            dy,\n            distance\n          } = getDistances(mouseClickPos, particle.position),\n          d = distance ** 2,\n          velocity = container.actualOptions.interactivity.modes.repulse.speed,\n          force = -repulseRadius * velocity / d;\n        if (d <= repulseRadius) {\n          container.repulse.particles.push(particle);\n          const vect = Vector.create(dx, dy);\n          vect.length = force;\n          particle.velocity.setTo(vect);\n        }\n      }\n    } else if (container.repulse.clicking === false) {\n      for (const particle of container.repulse.particles) {\n        particle.velocity.setTo(particle.initialVelocity);\n      }\n      container.repulse.particles = [];\n    }\n  }\n}","map":null,"metadata":{},"sourceType":"module"}