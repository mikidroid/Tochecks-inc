{"ast":null,"code":"var __classPrivateFieldSet = this && this.__classPrivateFieldSet || function (receiver, state, value, kind, f) {\n  if (kind === \"m\") throw new TypeError(\"Private method is not writable\");\n  if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a setter\");\n  if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot write private member to an object whose class did not declare it\");\n  return kind === \"a\" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value), value;\n};\nvar __classPrivateFieldGet = this && this.__classPrivateFieldGet || function (receiver, state, kind, f) {\n  if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a getter\");\n  if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot read private member from an object whose class did not declare it\");\n  return kind === \"m\" ? f : kind === \"a\" ? f.call(receiver) : f ? f.value : state.get(receiver);\n};\nvar _ImageDrawer_images;\nimport { downloadSvgImage, loadImage, replaceImageColor } from \"./Utils\";\nexport class ImageDrawer {\n  constructor() {\n    _ImageDrawer_images.set(this, void 0);\n    __classPrivateFieldSet(this, _ImageDrawer_images, [], \"f\");\n  }\n  getSidesCount() {\n    return 12;\n  }\n  getImages(container) {\n    const containerImages = __classPrivateFieldGet(this, _ImageDrawer_images, \"f\").find(t => t.id === container.id);\n    if (!containerImages) {\n      __classPrivateFieldGet(this, _ImageDrawer_images, \"f\").push({\n        id: container.id,\n        images: []\n      });\n      return this.getImages(container);\n    } else {\n      return containerImages;\n    }\n  }\n  addImage(container, image) {\n    const containerImages = this.getImages(container);\n    containerImages === null || containerImages === void 0 ? void 0 : containerImages.images.push(image);\n  }\n  destroy() {\n    __classPrivateFieldSet(this, _ImageDrawer_images, [], \"f\");\n  }\n  draw(context, particle, radius, opacity) {\n    var _a, _b;\n    const image = particle.image;\n    const element = (_a = image === null || image === void 0 ? void 0 : image.data) === null || _a === void 0 ? void 0 : _a.element;\n    if (!element) {\n      return;\n    }\n    const ratio = (_b = image === null || image === void 0 ? void 0 : image.ratio) !== null && _b !== void 0 ? _b : 1;\n    const pos = {\n      x: -radius,\n      y: -radius\n    };\n    if (!(image === null || image === void 0 ? void 0 : image.data.svgData) || !(image === null || image === void 0 ? void 0 : image.replaceColor)) {\n      context.globalAlpha = opacity;\n    }\n    context.drawImage(element, pos.x, pos.y, radius * 2, radius * 2 / ratio);\n    if (!(image === null || image === void 0 ? void 0 : image.data.svgData) || !(image === null || image === void 0 ? void 0 : image.replaceColor)) {\n      context.globalAlpha = 1;\n    }\n  }\n  loadShape(particle) {\n    var _a, _b, _c;\n    if (particle.shape !== \"image\" && particle.shape !== \"images\") {\n      return;\n    }\n    const images = this.getImages(particle.container).images;\n    const imageData = particle.shapeData;\n    const image = images.find(t => t.source === imageData.src);\n    let imageRes;\n    if (!image) {\n      this.loadImageShape(particle.container, imageData).then(() => {\n        this.loadShape(particle);\n      });\n      return;\n    }\n    if (image.error) {\n      return;\n    }\n    const color = particle.getFillColor();\n    if (image.svgData && imageData.replaceColor && color) {\n      imageRes = replaceImageColor(image, imageData, color, particle);\n    } else {\n      imageRes = {\n        data: image,\n        loaded: true,\n        ratio: imageData.width / imageData.height,\n        replaceColor: (_a = imageData.replaceColor) !== null && _a !== void 0 ? _a : imageData.replace_color,\n        source: imageData.src\n      };\n    }\n    if (!imageRes.ratio) {\n      imageRes.ratio = 1;\n    }\n    const fill = (_b = imageData.fill) !== null && _b !== void 0 ? _b : particle.fill;\n    const close = (_c = imageData.close) !== null && _c !== void 0 ? _c : particle.close;\n    const imageShape = {\n      image: imageRes,\n      fill,\n      close\n    };\n    particle.image = imageShape.image;\n    particle.fill = imageShape.fill;\n    particle.close = imageShape.close;\n  }\n  async loadImageShape(container, imageShape) {\n    const source = imageShape.src;\n    if (!source) {\n      throw new Error(\"Error tsParticles - No image.src\");\n    }\n    try {\n      const image = {\n        source: source,\n        type: source.substr(source.length - 3),\n        error: false,\n        loading: true\n      };\n      this.addImage(container, image);\n      const imageFunc = imageShape.replaceColor ? downloadSvgImage : loadImage;\n      await imageFunc(image);\n    } catch (_a) {\n      throw new Error(`tsParticles error - ${imageShape.src} not found`);\n    }\n  }\n}\n_ImageDrawer_images = new WeakMap();","map":null,"metadata":{},"sourceType":"module"}