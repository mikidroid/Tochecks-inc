{"ast":null,"code":"import { circleBounce, circleBounceDataFromParticle } from \"../../../Utils/Utils\";\nimport { clamp, getDistance } from \"../../../Utils/NumberUtils\";\nimport { ParticlesInteractorBase } from \"../../../Core/Utils/ParticlesInteractorBase\";\nfunction bounce(p1, p2) {\n  circleBounce(circleBounceDataFromParticle(p1), circleBounceDataFromParticle(p2));\n}\nfunction destroy(p1, p2) {\n  if (!p1.unbreakable && !p2.unbreakable) {\n    bounce(p1, p2);\n  }\n  if (p1.getRadius() === undefined && p2.getRadius() !== undefined) {\n    p1.destroy();\n  } else if (p1.getRadius() !== undefined && p2.getRadius() === undefined) {\n    p2.destroy();\n  } else if (p1.getRadius() !== undefined && p2.getRadius() !== undefined) {\n    if (p1.getRadius() >= p2.getRadius()) {\n      p2.destroy();\n    } else {\n      p1.destroy();\n    }\n  }\n}\nexport class Collider extends ParticlesInteractorBase {\n  constructor(container) {\n    super(container);\n  }\n  isEnabled(particle) {\n    return particle.options.collisions.enable;\n  }\n  reset() {}\n  async interact(p1) {\n    const container = this.container,\n      pos1 = p1.getPosition(),\n      radius1 = p1.getRadius(),\n      query = container.particles.quadTree.queryCircle(pos1, radius1 * 2);\n    for (const p2 of query) {\n      if (p1 === p2 || !p2.options.collisions.enable || p1.options.collisions.mode !== p2.options.collisions.mode || p2.destroyed || p2.spawning) {\n        continue;\n      }\n      const pos2 = p2.getPosition();\n      if (Math.round(pos1.z) !== Math.round(pos2.z)) {\n        continue;\n      }\n      const dist = getDistance(pos1, pos2),\n        radius2 = p2.getRadius(),\n        distP = radius1 + radius2;\n      if (dist <= distP) {\n        this.resolveCollision(p1, p2);\n      }\n    }\n  }\n  resolveCollision(p1, p2) {\n    switch (p1.options.collisions.mode) {\n      case \"absorb\":\n        this.absorb(p1, p2);\n        break;\n      case \"bounce\":\n        bounce(p1, p2);\n        break;\n      case \"destroy\":\n        destroy(p1, p2);\n        break;\n    }\n  }\n  absorb(p1, p2) {\n    const container = this.container,\n      fps = container.fpsLimit / 1000;\n    if (p1.getRadius() === undefined && p2.getRadius() !== undefined) {\n      p1.destroy();\n    } else if (p1.getRadius() !== undefined && p2.getRadius() === undefined) {\n      p2.destroy();\n    } else if (p1.getRadius() !== undefined && p2.getRadius() !== undefined) {\n      if (p1.getRadius() >= p2.getRadius()) {\n        const factor = clamp(p1.getRadius() / p2.getRadius(), 0, p2.getRadius()) * fps;\n        p1.size.value += factor;\n        p2.size.value -= factor;\n        if (p2.getRadius() <= container.retina.pixelRatio) {\n          p2.size.value = 0;\n          p2.destroy();\n        }\n      } else {\n        const factor = clamp(p2.getRadius() / p1.getRadius(), 0, p1.getRadius()) * fps;\n        p1.size.value -= factor;\n        p2.size.value += factor;\n        if (p1.getRadius() <= container.retina.pixelRatio) {\n          p1.size.value = 0;\n          p1.destroy();\n        }\n      }\n    }\n  }\n}","map":null,"metadata":{},"sourceType":"module"}