{"ast":null,"code":"import { applyDistance, applyPath, getProximitySpeedFactor, spin } from \"./Utils\";\nimport { getDistance, getRangeMax, getRangeValue } from \"../../Utils/NumberUtils\";\nexport class BaseMover {\n  init(particle) {\n    var _a;\n    const container = particle.container,\n      options = particle.options,\n      spinOptions = options.move.spin;\n    if (spinOptions.enable) {\n      const spinPos = (_a = spinOptions.position) !== null && _a !== void 0 ? _a : {\n        x: 50,\n        y: 50\n      };\n      const spinCenter = {\n        x: spinPos.x / 100 * container.canvas.size.width,\n        y: spinPos.y / 100 * container.canvas.size.height\n      };\n      const pos = particle.getPosition();\n      const distance = getDistance(pos, spinCenter);\n      const spinAcceleration = getRangeValue(spinOptions.acceleration);\n      particle.retina.spinAcceleration = spinAcceleration * container.retina.pixelRatio;\n      particle.spin = {\n        center: spinCenter,\n        direction: particle.velocity.x >= 0 ? \"clockwise\" : \"counter-clockwise\",\n        angle: particle.velocity.angle,\n        radius: distance,\n        acceleration: particle.retina.spinAcceleration\n      };\n    }\n  }\n  isEnabled(particle) {\n    return !particle.destroyed && particle.options.move.enable;\n  }\n  move(particle, delta) {\n    var _a, _b, _c;\n    var _d, _e;\n    const particleOptions = particle.options,\n      moveOptions = particleOptions.move;\n    if (!moveOptions.enable) {\n      return;\n    }\n    const container = particle.container,\n      slowFactor = getProximitySpeedFactor(particle),\n      baseSpeed = ((_a = (_d = particle.retina).moveSpeed) !== null && _a !== void 0 ? _a : _d.moveSpeed = getRangeValue(moveOptions.speed) * container.retina.pixelRatio) * container.retina.reduceFactor,\n      moveDrift = (_b = (_e = particle.retina).moveDrift) !== null && _b !== void 0 ? _b : _e.moveDrift = getRangeValue(particle.options.move.drift) * container.retina.pixelRatio,\n      maxSize = getRangeMax(particleOptions.size.value) * container.retina.pixelRatio,\n      sizeFactor = moveOptions.size ? particle.getRadius() / maxSize : 1,\n      speedFactor = sizeFactor * slowFactor * (delta.factor || 1),\n      diffFactor = 2,\n      moveSpeed = baseSpeed * speedFactor / diffFactor;\n    applyPath(particle, delta);\n    const gravityOptions = particle.gravity,\n      gravityFactor = gravityOptions.enable && gravityOptions.inverse ? -1 : 1;\n    if (gravityOptions.enable && moveSpeed) {\n      particle.velocity.y += gravityFactor * (gravityOptions.acceleration * delta.factor) / (60 * moveSpeed);\n    }\n    if (moveDrift && moveSpeed) {\n      particle.velocity.x += moveDrift * delta.factor / (60 * moveSpeed);\n    }\n    const decay = particle.moveDecay;\n    if (decay != 1) {\n      particle.velocity.multTo(decay);\n    }\n    const velocity = particle.velocity.mult(moveSpeed),\n      maxSpeed = (_c = particle.retina.maxSpeed) !== null && _c !== void 0 ? _c : container.retina.maxSpeed;\n    if (gravityOptions.enable && maxSpeed > 0 && (!gravityOptions.inverse && velocity.y >= 0 && velocity.y >= maxSpeed || gravityOptions.inverse && velocity.y <= 0 && velocity.y <= -maxSpeed)) {\n      velocity.y = gravityFactor * maxSpeed;\n      if (moveSpeed) {\n        particle.velocity.y = velocity.y / moveSpeed;\n      }\n    }\n    const zIndexOptions = particle.options.zIndex,\n      zVelocityFactor = (1 - particle.zIndexFactor) ** zIndexOptions.velocityRate;\n    if (moveOptions.spin.enable) {\n      spin(particle, moveSpeed);\n    } else {\n      if (zVelocityFactor != 1) {\n        velocity.multTo(zVelocityFactor);\n      }\n      particle.position.addTo(velocity);\n      if (moveOptions.vibrate) {\n        particle.position.x += Math.sin(particle.position.x * Math.cos(particle.position.y));\n        particle.position.y += Math.cos(particle.position.y * Math.sin(particle.position.x));\n      }\n    }\n    applyDistance(particle);\n  }\n}","map":null,"metadata":{},"sourceType":"module"}