{"ast":null,"code":"import { clamp, getDistance, getRangeMax } from \"../../../Utils/NumberUtils\";\nimport { colorMix, colorToHsl, rgbToHsl } from \"../../../Utils/ColorUtils\";\nimport { divMode, divModeExecute, isDivModeEnabled, isInArray, itemFromArray } from \"../../../Utils/Utils\";\nimport { Circle } from \"../../../Core/Utils/Circle\";\nimport { Constants } from \"../../../Core/Utils/Constants\";\nimport { ExternalInteractorBase } from \"../../../Core/Utils/ExternalInteractorBase\";\nimport { Rectangle } from \"../../../Core/Utils/Rectangle\";\nfunction calculateBubbleValue(particleValue, modeValue, optionsValue, ratio) {\n  if (modeValue >= optionsValue) {\n    const value = particleValue + (modeValue - optionsValue) * ratio;\n    return clamp(value, particleValue, modeValue);\n  } else if (modeValue < optionsValue) {\n    const value = particleValue - (optionsValue - modeValue) * ratio;\n    return clamp(value, modeValue, particleValue);\n  }\n}\nexport class Bubbler extends ExternalInteractorBase {\n  constructor(container) {\n    super(container);\n    if (!container.bubble) {\n      container.bubble = {};\n    }\n    this.handleClickMode = mode => {\n      if (mode !== \"bubble\") {\n        return;\n      }\n      if (!container.bubble) {\n        container.bubble = {};\n      }\n      container.bubble.clicking = true;\n    };\n  }\n  isEnabled() {\n    const container = this.container,\n      options = container.actualOptions,\n      mouse = container.interactivity.mouse,\n      events = options.interactivity.events,\n      divs = events.onDiv,\n      divBubble = isDivModeEnabled(\"bubble\", divs);\n    if (!(divBubble || events.onHover.enable && mouse.position || events.onClick.enable && mouse.clickPosition)) {\n      return false;\n    }\n    const hoverMode = events.onHover.mode;\n    const clickMode = events.onClick.mode;\n    return isInArray(\"bubble\", hoverMode) || isInArray(\"bubble\", clickMode) || divBubble;\n  }\n  reset(particle, force) {\n    if (!(!particle.bubble.inRange || force)) {\n      return;\n    }\n    delete particle.bubble.div;\n    delete particle.bubble.opacity;\n    delete particle.bubble.radius;\n    delete particle.bubble.color;\n  }\n  async interact() {\n    const options = this.container.actualOptions,\n      events = options.interactivity.events,\n      onHover = events.onHover,\n      onClick = events.onClick,\n      hoverEnabled = onHover.enable,\n      hoverMode = onHover.mode,\n      clickEnabled = onClick.enable,\n      clickMode = onClick.mode,\n      divs = events.onDiv;\n    if (hoverEnabled && isInArray(\"bubble\", hoverMode)) {\n      this.hoverBubble();\n    } else if (clickEnabled && isInArray(\"bubble\", clickMode)) {\n      this.clickBubble();\n    } else {\n      divModeExecute(\"bubble\", divs, (selector, div) => this.singleSelectorHover(selector, div));\n    }\n  }\n  singleSelectorHover(selector, div) {\n    const container = this.container,\n      selectors = document.querySelectorAll(selector);\n    if (!selectors.length) {\n      return;\n    }\n    selectors.forEach(item => {\n      const elem = item,\n        pxRatio = container.retina.pixelRatio,\n        pos = {\n          x: (elem.offsetLeft + elem.offsetWidth / 2) * pxRatio,\n          y: (elem.offsetTop + elem.offsetHeight / 2) * pxRatio\n        },\n        repulseRadius = elem.offsetWidth / 2 * pxRatio,\n        area = div.type === \"circle\" ? new Circle(pos.x, pos.y, repulseRadius) : new Rectangle(elem.offsetLeft * pxRatio, elem.offsetTop * pxRatio, elem.offsetWidth * pxRatio, elem.offsetHeight * pxRatio),\n        query = container.particles.quadTree.query(area);\n      for (const particle of query) {\n        if (!area.contains(particle.getPosition())) {\n          continue;\n        }\n        particle.bubble.inRange = true;\n        const divs = container.actualOptions.interactivity.modes.bubble.divs;\n        const divBubble = divMode(divs, elem);\n        if (!particle.bubble.div || particle.bubble.div !== elem) {\n          this.reset(particle, true);\n          particle.bubble.div = elem;\n        }\n        this.hoverBubbleSize(particle, 1, divBubble);\n        this.hoverBubbleOpacity(particle, 1, divBubble);\n        this.hoverBubbleColor(particle, 1, divBubble);\n      }\n    });\n  }\n  process(particle, distMouse, timeSpent, data) {\n    const container = this.container,\n      bubbleParam = data.bubbleObj.optValue;\n    if (bubbleParam === undefined) {\n      return;\n    }\n    const options = container.actualOptions,\n      bubbleDuration = options.interactivity.modes.bubble.duration,\n      bubbleDistance = container.retina.bubbleModeDistance,\n      particlesParam = data.particlesObj.optValue,\n      pObjBubble = data.bubbleObj.value,\n      pObj = data.particlesObj.value || 0,\n      type = data.type;\n    if (bubbleParam === particlesParam) {\n      return;\n    }\n    if (!container.bubble) {\n      container.bubble = {};\n    }\n    if (!container.bubble.durationEnd) {\n      if (distMouse <= bubbleDistance) {\n        const obj = pObjBubble !== null && pObjBubble !== void 0 ? pObjBubble : pObj;\n        if (obj !== bubbleParam) {\n          const value = pObj - timeSpent * (pObj - bubbleParam) / bubbleDuration;\n          if (type === \"size\") {\n            particle.bubble.radius = value;\n          }\n          if (type === \"opacity\") {\n            particle.bubble.opacity = value;\n          }\n        }\n      } else {\n        if (type === \"size\") {\n          delete particle.bubble.radius;\n        }\n        if (type === \"opacity\") {\n          delete particle.bubble.opacity;\n        }\n      }\n    } else if (pObjBubble) {\n      if (type === \"size\") {\n        delete particle.bubble.radius;\n      }\n      if (type === \"opacity\") {\n        delete particle.bubble.opacity;\n      }\n    }\n  }\n  clickBubble() {\n    var _a, _b;\n    const container = this.container,\n      options = container.actualOptions,\n      mouseClickPos = container.interactivity.mouse.clickPosition;\n    if (!mouseClickPos) {\n      return;\n    }\n    if (!container.bubble) {\n      container.bubble = {};\n    }\n    const distance = container.retina.bubbleModeDistance,\n      query = container.particles.quadTree.queryCircle(mouseClickPos, distance);\n    for (const particle of query) {\n      if (!container.bubble.clicking) {\n        continue;\n      }\n      particle.bubble.inRange = !container.bubble.durationEnd;\n      const pos = particle.getPosition(),\n        distMouse = getDistance(pos, mouseClickPos),\n        timeSpent = (new Date().getTime() - (container.interactivity.mouse.clickTime || 0)) / 1000;\n      if (timeSpent > options.interactivity.modes.bubble.duration) {\n        container.bubble.durationEnd = true;\n      }\n      if (timeSpent > options.interactivity.modes.bubble.duration * 2) {\n        container.bubble.clicking = false;\n        container.bubble.durationEnd = false;\n      }\n      const sizeData = {\n        bubbleObj: {\n          optValue: container.retina.bubbleModeSize,\n          value: particle.bubble.radius\n        },\n        particlesObj: {\n          optValue: getRangeMax(particle.options.size.value) * container.retina.pixelRatio,\n          value: particle.size.value\n        },\n        type: \"size\"\n      };\n      this.process(particle, distMouse, timeSpent, sizeData);\n      const opacityData = {\n        bubbleObj: {\n          optValue: options.interactivity.modes.bubble.opacity,\n          value: particle.bubble.opacity\n        },\n        particlesObj: {\n          optValue: getRangeMax(particle.options.opacity.value),\n          value: (_b = (_a = particle.opacity) === null || _a === void 0 ? void 0 : _a.value) !== null && _b !== void 0 ? _b : 1\n        },\n        type: \"opacity\"\n      };\n      this.process(particle, distMouse, timeSpent, opacityData);\n      if (!container.bubble.durationEnd) {\n        if (distMouse <= container.retina.bubbleModeDistance) {\n          this.hoverBubbleColor(particle, distMouse);\n        } else {\n          delete particle.bubble.color;\n        }\n      } else {\n        delete particle.bubble.color;\n      }\n    }\n  }\n  hoverBubble() {\n    const container = this.container,\n      mousePos = container.interactivity.mouse.position;\n    if (mousePos === undefined) {\n      return;\n    }\n    const distance = container.retina.bubbleModeDistance,\n      query = container.particles.quadTree.queryCircle(mousePos, distance);\n    for (const particle of query) {\n      particle.bubble.inRange = true;\n      const pos = particle.getPosition(),\n        pointDistance = getDistance(pos, mousePos),\n        ratio = 1 - pointDistance / distance;\n      if (pointDistance <= distance) {\n        if (ratio >= 0 && container.interactivity.status === Constants.mouseMoveEvent) {\n          this.hoverBubbleSize(particle, ratio);\n          this.hoverBubbleOpacity(particle, ratio);\n          this.hoverBubbleColor(particle, ratio);\n        }\n      } else {\n        this.reset(particle);\n      }\n      if (container.interactivity.status === Constants.mouseLeaveEvent) {\n        this.reset(particle);\n      }\n    }\n  }\n  hoverBubbleSize(particle, ratio, divBubble) {\n    const container = this.container,\n      modeSize = (divBubble === null || divBubble === void 0 ? void 0 : divBubble.size) ? divBubble.size * container.retina.pixelRatio : container.retina.bubbleModeSize;\n    if (modeSize === undefined) {\n      return;\n    }\n    const optSize = getRangeMax(particle.options.size.value) * container.retina.pixelRatio;\n    const pSize = particle.size.value;\n    const size = calculateBubbleValue(pSize, modeSize, optSize, ratio);\n    if (size !== undefined) {\n      particle.bubble.radius = size;\n    }\n  }\n  hoverBubbleOpacity(particle, ratio, divBubble) {\n    var _a, _b, _c;\n    const container = this.container,\n      options = container.actualOptions,\n      modeOpacity = (_a = divBubble === null || divBubble === void 0 ? void 0 : divBubble.opacity) !== null && _a !== void 0 ? _a : options.interactivity.modes.bubble.opacity;\n    if (!modeOpacity) {\n      return;\n    }\n    const optOpacity = particle.options.opacity.value;\n    const pOpacity = (_c = (_b = particle.opacity) === null || _b === void 0 ? void 0 : _b.value) !== null && _c !== void 0 ? _c : 1;\n    const opacity = calculateBubbleValue(pOpacity, modeOpacity, getRangeMax(optOpacity), ratio);\n    if (opacity !== undefined) {\n      particle.bubble.opacity = opacity;\n    }\n  }\n  hoverBubbleColor(particle, ratio, divBubble) {\n    const options = this.container.actualOptions;\n    const bubbleOptions = divBubble !== null && divBubble !== void 0 ? divBubble : options.interactivity.modes.bubble;\n    if (!particle.bubble.finalColor) {\n      const modeColor = bubbleOptions.color;\n      if (!modeColor) {\n        return;\n      }\n      const bubbleColor = modeColor instanceof Array ? itemFromArray(modeColor) : modeColor;\n      particle.bubble.finalColor = colorToHsl(bubbleColor);\n    }\n    if (!particle.bubble.finalColor) {\n      return;\n    }\n    if (bubbleOptions.mix) {\n      particle.bubble.color = undefined;\n      const pColor = particle.getFillColor();\n      particle.bubble.color = pColor ? rgbToHsl(colorMix(pColor, particle.bubble.finalColor, 1 - ratio, ratio)) : particle.bubble.finalColor;\n    } else {\n      particle.bubble.color = particle.bubble.finalColor;\n    }\n  }\n}","map":null,"metadata":{},"sourceType":"module"}